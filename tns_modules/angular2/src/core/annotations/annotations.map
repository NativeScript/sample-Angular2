{"version":3,"sources":["annotations.js"],"names":[],"mappings":"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","file":"/home/korchev/github/angular/modules/angular2/src/core/annotations/annotations.js","sourcesContent":["import {ABSTRACT, CONST, normalizeBlank, isPresent} from 'angular2/src/facade/lang';\nimport {ListWrapper, List} from 'angular2/src/facade/collection';\nimport {Injectable} from 'angular2/di';\n\n// type StringMap = {[idx: string]: string};\n\n/**\n * Directives allow you to attach behavior to elements in the DOM.\n *\n * Directive is an abstract concept, instead use concrete directives: [Component], [DynamicComponent], [Decorator]\n * or [Viewport].\n *\n * A directive consists of a single directive annotation and a controller class. When the directive's [selector] matches\n * elements in the DOM, the following steps occur:\n *\n * 1. For each directive, the [ElementInjector] attempts to resolve the directive's constructor arguments.\n * 2. Angular instantiates directives for each matched element using [ElementInjector] in a depth-first order,\n *    as declared in the HTML.\n *\n * ## Understanding How Injection Works\n *\n * There are three stages of injection resolution.\n * - *Pre-existing Injectors*:\n *   - The terminal [Injector] cannot resolve dependencies. It either throws an error or, if the dependency was\n *     specified as `@Optional`, returns `null`.\n *   - The primordial injector resolves browser singleton resources, such as: cookies, title, location, and others.\n * - *Component Injectors*: Each `@Component` has its own [Injector], and they follow the same parent-child hierarchy\n *     as the components in the DOM.\n * - *Element Injectors*: Each component has a Shadow DOM. Within the Shadow DOM each element has an [ElementInjector]\n *     which follow the same parent-child hierarchy as the DOM elements themselves.\n *\n * When a template is instantiated, it also must instantiate the corresponding directives in a depth-first order. The\n * current [ElementInjector] resolves the constructor dependencies for each directive.\n *\n * Angular then resolves dependencies as follows, according to the order in which they appear in the [View]:\n *\n * 1. Dependencies on the current element\n * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary\n * 3. Dependencies on component injectors and their parents until it encounters the root component\n * 4. Dependencies on pre-existing injectors\n *\n *\n * The [ElementInjector] can inject other directives, element-specific special objects, or it can delegate to the parent\n * injector.\n *\n * To inject other directives, declare the constructor parameter as:\n * - `directive:DirectiveType`: a directive on the current element only\n * - `@Ancestor() directive:DirectiveType`: any directive that matches the type between the current element and the\n *    Shadow DOM root. Current element is not included in the resolution, therefor even if it could resolve it, it will\n *    be ignored.\n * - `@Parent() directive:DirectiveType`: any directive that matches the type on a direct parent element only.\n * - `@Children query:Query<DirectiveType>`: A live collection of direct child directives [TO BE IMPLEMENTED].\n * - `@Descendants query:Query<DirectiveType>`: A live collection of any child directives [TO BE IMPLEMENTED].\n *\n * To inject element-specific special objects, declare the constructor parameter as:\n * - `element: NgElement` to obtain a DOM element (DEPRECATED: replacement coming)\n * - `viewContainer: ViewContainer` to control child template instantiation, for [Viewport] directives only\n * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.\n *\n * ## Example\n *\n * The following example demonstrates how dependency injection resolves constructor arguments in practice.\n *\n *\n * Assume this HTML template:\n *\n * ```\n * <div dependency=\"1\">\n *   <div dependency=\"2\">\n *     <div dependency=\"3\" my-directive>\n *       <div dependency=\"4\">\n *         <div dependency=\"5\"></div>\n *       </div>\n *       <div dependency=\"6\"></div>\n *     </div>\n *   </div>\n * </div>\n * ```\n *\n * With the following `dependency` decorator and `SomeService` injectable class.\n *\n * ```\n * @Injectable()\n * class SomeService {\n * }\n *\n * @Decorator({\n *   selector: '[dependency]',\n *   bind: {\n *     'id':'dependency'\n *   }\n * })\n * class Dependency {\n *   id:string;\n * }\n * ```\n *\n * Let's step through the different ways in which `MyDirective` could be declared...\n *\n *\n * ### No injection\n *\n * Here the constructor is declared with no arguments, therefore nothing is injected into `MyDirective`.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor() {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with no dependencies.\n *\n *\n * ### Component-level injection\n *\n * Directives can inject any injectable instance from the closest component injector or any of its parents.\n *\n * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type from the parent\n * component's injector.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(someService: SomeService) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a dependency on `SomeService`.\n *\n *\n * ### Injecting a directive from the current element\n *\n * Directives can inject other directives declared on the current element.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(dependency: Dependency) {\n *     expect(dependency.id).toEqual(3);\n *   }\n * }\n * ```\n * This directive would be instantiated with `Dependency` declared at the same element, in this case `dependency=\"3\"`.\n *\n *\n * ### Injecting a directive from a direct parent element\n *\n * Directives can inject other directives declared on a direct parent element. By definition, a directive with a\n * `@Parent` annotation does not attempt to resolve dependencies for the current element, even if this would satisfy\n * the dependency.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Parent() dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n * This directive would be instantiated with `Dependency` declared at the parent element, in this case `dependency=\"2\"`.\n *\n *\n * ### Injecting a directive from any ancestor elements\n *\n * Directives can inject other directives declared on any ancestor element (in the current Shadow DOM), i.e. on the\n * parent element and its parents. By definition, a directive with an `@Ancestor` annotation does not attempt to\n * resolve dependencies for the current element, even if this would satisfy the dependency.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Ancestor() dependency: Dependency) {\n *     expect(dependency.id).toEqual(2);\n *   }\n * }\n * ```\n *\n * Unlike the `@Parent` which only checks the parent, `@Ancestor` checks the parent, as well as its\n * parents recursively. If `dependency=\"2\"` didn't exist on the direct parent, this injection would have returned\n * `dependency=\"1\"`.\n *\n *\n * ### Injecting a live collection of direct child directives [PENDING IMPLEMENTATION]\n *\n * A directive can also query for other child directives. Since parent directives are instantiated before child\n * directives, a directive can't simply inject the list of child directives. Instead, the directive asynchronously\n * injects a [Query], which updates as children are added, removed, or moved by any [ViewPort] directive such as a\n * `for`, an `if`, or a `switch`.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Children() dependencies:Query<Maker>) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a [Query] which contains `Dependency` 4 and 6. Here, `Dependency` 5 would\n * not be included, because it is not a direct child.\n *\n * ### Injecting a live collection of direct descendant directives [PENDING IMPLEMENTATION]\n *\n * Similar to `@Children` above, but also includes the children of the child elements.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Children() dependencies:Query<Maker>) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.\n *\n * ### Optional injection\n *\n * The normal behavior of directives is to return an error when a specified dependency cannot be resolved. If you\n * would like to inject `null` on unresolved dependency instead, you can annotate that dependency with `@Optional()`.\n * This explicitly permits the author of a template to treat some of the surrounding directives as optional.\n *\n * ```\n * @Decorator({ selector: '[my-directive]' })\n * class MyDirective {\n *   constructor(@Optional() dependency:Dependency) {\n *   }\n * }\n * ```\n *\n * This directive would be instantiated with a `Dependency` directive found on the current element. If none can be\n * found, the injector supplies `null` instead of throwing an error.\n *\n * @publicModule angular2/annotations\n */\n@ABSTRACT()\nexport class Directive extends Injectable {\n  /**\n   * The CSS selector that triggers the instantiation of a directive.\n   *\n   * Angular only allows directives to trigger on CSS selectors that do not cross element boundaries.\n   *\n   * `selector` may be declared as one of the following:\n   *\n   * - `element-name`: select by element name.\n   * - `.class`: select by class name.\n   * - `[attribute]`: select by attribute name.\n   * - `[attribute=value]`: select by attribute name and value.\n   * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n   *\n   *\n   * ## Example\n   *\n   * Suppose we have a directive with an `input[type=text]` selector.\n   *\n   * And the following HTML:\n   *\n   * ```html\n   * <form>\n   *   <input type=\"text\">\n   *   <input type=\"radio\">\n   * <form>\n   * ```\n   *\n   * The directive would only be instantiated on the `<input type=\"text\">` element.\n   *\n   */\n  selector:string;\n\n  /**\n   * Enumerates the set of properties that accept data binding for a directive.\n   *\n   * The `bind` property defines a set of `directiveProperty` to `bindingProperty` key-value pairs:\n   *\n   * - `directiveProperty` specifies the component property where the value is written.\n   * - `bindingProperty` specifies the DOM property where the value is read from.\n   *\n   * You can include [Pipes] when specifying a `bindingProperty` to allow for data transformation and structural\n   * change detection of the value. These pipes will be evaluated in the context of this component.\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   bind: {\n   *     'directiveProperty1': 'bindingProperty1',\n   *     'directiveProperty2': 'bindingProperty2 | pipe1 | ...',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   *\n   * ## Basic Property Binding\n   *\n   * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can be used in templates\n   * with standard Angular syntax. For example:\n   *\n   * ```\n   * @Decorator({\n   *   selector: '[tooltip]',\n   *   bind: {\n   *     'text': 'tooltip'\n   *   }\n   * })\n   * class Tooltip {\n   *   set text(text) {\n   *     // This will get called every time the 'tooltip' binding changes with the new value.\n   *   }\n   * }\n   * ```\n   *\n   * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a string literal, as\n   * shown in the HTML template below:\n   *\n   * ```html\n   * <div [tooltip]=\"someExpression\">...</div>\n   * <div tooltip=\"Some Text\">...</div>\n   * ```\n   *\n   * Whenever the `someExpression` expression changes, the `bind` declaration instructs Angular to update the\n   * `Tooltip`'s `text` property.\n   *\n   *\n   *\n   * ## Bindings With Pipes\n   *\n   * You can also use pipes when writing binding definitions for a directive.\n   *\n   * For example, we could write a binding that updates the directive on structural changes, rather than on reference\n   * changes, as normally occurs in change detection. (See: [Pipe] and [keyValueDiff] documentation for more details.)\n   *\n   * ```\n   * @Decorator({\n   *   selector: '[class-set]',\n   *   bind: {\n   *     'classChanges': 'classSet | keyValDiff'\n   *   }\n   * })\n   * class ClassSet {\n   *   set classChanges(changes:KeyValueChanges) {\n   *     // This will get called every time the `class-set` expressions changes its structure.\n   *   }\n   * }\n   * ```\n   *\n   * The template that this directive is used in may also contain its own pipes. For example:\n   *\n   * ```html\n   * <div [class-set]=\"someExpression | somePipe\">\n   * ```\n   *\n   * In this case, the two pipes compose as if they were inlined: `someExpression | somePipe | keyValDiff`.\n   *\n   */\n  bind:any; //  StringMap\n\n  /**\n   * Specifies which DOM events a directive listens to.\n   *\n   * The `events` property defines a set of `event` to `method` key-value pairs:\n   *\n   * - `event1`: the DOM event that the directive listens to.\n   * - `statement`: the statement to execute when the event occurs.\n   *\n   *\n   * When writing a directive event binding, you can also refer to the following local variables:\n   * - `$event`: Current event object which triggered the event.\n   * - `$target`: The source of the event. This will be either a DOM element or an Angular directive.\n   *    [TO BE IMPLEMENTED]\n   *\n   *\n   * ## Syntax\n   *\n   * ```\n   * @Directive({\n   *   events: {\n   *     'event1': 'onMethod1(arguments)',\n   *     ...\n   *   }\n   * }\n   * ```\n   *\n   * ## Basic Event Binding:\n   *\n   * Suppose you want to write a directive that triggers on `change` events in the DOM. You would define the event\n   * binding as follows:\n   *\n   * ```\n   * @Decorator({\n   *   selector: 'input',\n   *   events: {\n   *     'change': 'onChange($event)'\n   *   }\n   * })\n   * class InputDecorator {\n   *   onChange(event:Event) {\n   *   }\n   * }\n   * ```\n   *\n   * Here the `onChange` method of `InputDecorator` is invoked whenever the DOM element fires the 'change' event.\n   *\n   */\n  events:any; //  StringMap\n\n  /**\n   * Specifies a set of lifecycle events in which the directive participates.\n   *\n   * See: [onChange], [onDestroy], [onAllChangesDone] for details.\n   */\n  lifecycle:List; //List<LifecycleEvent>\n\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle\n    }:{\n      selector:string,\n      bind:any,\n      events: any,\n      lifecycle:List\n    }={})\n  {\n    super();\n    this.selector = selector;\n    this.bind = bind;\n    this.events = events;\n    this.lifecycle = lifecycle;\n  }\n\n  /**\n   * Returns true if a directive participates in a given [LifecycleEvent].\n   *\n   * See: [onChange], [onDestroy], [onAllChangesDone] for details.\n   */\n  hasLifecycleHook(hook:string):boolean {\n    return isPresent(this.lifecycle) ? ListWrapper.contains(this.lifecycle, hook) : false;\n  }\n}\n\n/**\n * Declare reusable UI building blocks for an application.\n *\n * Each Angular component requires a single `@Component` and at least one `@Template` annotation. The `@Component`\n * annotation specifies when a component is instantiated, and which properties and events it binds to.\n *\n * When a component is instantiated, Angular\n * - creates a shadow DOM for the component.\n * - loads the selected template into the shadow DOM.\n * - creates a child [Injector] which is configured with the [Component.services].\n *\n * All template expressions and statements are then evaluated against the component instance.\n *\n * For details on the `@Template` annotation, see [Template].\n *\n * ## Example\n *\n * ```\n * @Component({\n *   selector: 'greet'\n * })\n * @Template({\n *   inline: 'Hello {{name}}!'\n * })\n * class Greet {\n *   name: string;\n *\n *   constructor() {\n *     this.name = 'World';\n *   }\n * }\n * ```\n *\n * @publicModule angular2/annotations\n */\nexport class Component extends Directive {\n  /**\n   * Defines the used change detection strategy.\n   *\n   * When a component is instantiated, Angular creates a change detector, which is responsible for propagating\n   * the component's bindings.\n   *\n   * The `changeDetection` property defines, whether the change detection will be checked every time or only when the component\n   * tells it to do so.\n   */\n  changeDetection:string;\n\n  /**\n   * Defines the set of injectable objects that are visible to a Component and its children.\n   *\n   * The [services] defined in the Component annotation allow you to configure a set of bindings for the component's\n   * injector.\n   *\n   * When a component is instantiated, Angular creates a new child Injector, which is configured with the bindings in\n   * the Component [services] annotation. The injectable objects then become available for injection to the component\n   * itself and any of the directives in the component's template, i.e. they are not available to the directives which\n   * are children in the component's light DOM.\n   *\n   *\n   * The syntax for configuring the [services] injectable is identical to [Injector] injectable configuration. See\n   * [Injector] for additional detail.\n   *\n   *\n   * ## Simple Example\n   *\n   * Here is an example of a class that can be injected:\n   *\n   * ```\n   * class Greeter {\n   *    greet(name:string) {\n   *      return 'Hello ' + name + '!';\n   *    }\n   * }\n   *\n   * @Component({\n   *   selector: 'greet',\n   *   services: [\n   *     Greeter\n   *   ]\n   * })\n   * @Template({\n   *   inline: `{{greeter.greet('world')}}!`,\n   *   directives: Child\n   * })\n   * class HelloWorld {\n   *   greeter:Greeter;\n   *\n   *   constructor(greeter:Greeter) {\n   *     this.greeter = greeter;\n   *   }\n   * }\n   * ```\n   */\n  services:List;\n\n@CONST()\n  constructor({\n    selector,\n    bind,\n    events,\n    services,\n    lifecycle,\n    changeDetection\n    }:{\n      selector:string,\n      bind:Object,\n      events:Object,\n      services:List,\n      lifecycle:List,\n      changeDetection:string\n    }={})\n  {\n    super({\n      selector: selector,\n      bind: bind,\n      events: events,\n      lifecycle: lifecycle\n    });\n\n    this.changeDetection = changeDetection;\n    this.services = services;\n  }\n}\n\n/**\n * Directive used for dynamically loading components.\n *\n * Regular Angular components are statically resolved. DynamicComponent allows to you resolve a component at runtime\n * instead by providing a placeholder into which a regular Angular component can be dynamically loaded. Once loaded,\n * the dynamically-loaded component becomes permanent and cannot be changed.\n *\n *\n * ## Example\n *\n * Here we have `DynamicComp` which acts as the placeholder for `HelloCmp`. At runtime, the dynamic component\n * `DynamicComp` requests loading of the `HelloCmp` component.\n *\n * There is nothing special about `HelloCmp`, which is a regular Angular component. It can also be used in other static\n * locations.\n *\n * ```\n * @DynamicComponent({\n *   selector: 'dynamic-comp'\n * })\n * class DynamicComp {\n *   helloCmp:HelloCmp;\n *   constructor(loader:PrivateComponentLoader, location:PrivateComponentLocation) {\n *     loader.load(HelloCmp, location).then((helloCmp) => {\n *       this.helloCmp = helloCmp;\n *     });\n *   }\n * }\n *\n * @Component({\n *   selector: 'hello-cmp'\n * })\n * @Template({\n *   inline: \"{{greeting}}\"\n * })\n * class HelloCmp {\n *   greeting:string;\n *   constructor() {\n *     this.greeting = \"hello\";\n *   }\n * }\n * ```\n *\n *\n *\n * @publicModule angular2/annotations\n */\nexport class DynamicComponent extends Directive {\n  /**\n   * Same as [Component.services].\n   */\n  // TODO(vsankin): Please extract into AbstractComponent\n  services:any; //List;\n\n  @CONST()\n  constructor({\n    selector,\n    bind,\n    events,\n    services,\n    lifecycle\n    }:{\n      selector:string,\n      bind:Object,\n      events:Object,\n      services:List,\n      lifecycle:List\n    }={}) {\n    super({\n      selector: selector,\n      bind: bind,\n      events: events,\n      lifecycle: lifecycle\n    });\n\n    this.services = services;\n  }\n}\n\n/**\n * Directive that attaches behavior to DOM elements.\n *\n * A decorator directive attaches behavior to a DOM element in a composable manner.\n * (see: http://en.wikipedia.org/wiki/Composition_over_inheritance)\n *\n * Decorators:\n * - are simplest form of [Directive]s.\n * - are best used as a composition pattern ()\n *\n * Decorators differ from [Component]s in that they:\n * - can have multiple decorators per element\n * - do not create their own evaluation context\n * - do not have a template (and therefor do not create Shadow DOM)\n *\n *\n * ## Example\n *\n * Here we use a decorator directive to simply define basic tool-tip behavior.\n *\n * ```\n * @Decorator({\n *   selector: '[tooltip]',\n *   bind: {\n *     'text': 'tooltip'\n *   },\n *   events: {\n *     'onmouseenter': 'onMouseEnter()',\n *     'onmouseleave': 'onMouseLeave()'\n *   }\n * })\n * class Tooltip{\n *   text:string;\n *   overlay:Overlay; // NOT YET IMPLEMENTED\n *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED\n *\n *   constructor(overlayManager:OverlayManager) {\n *     this.overlay = overlay;\n *   }\n *\n *   onMouseEnter() {\n *     // exact signature to be determined\n *     this.overlay = this.overlayManager.open(text, ...);\n *   }\n *\n *   onMouseLeave() {\n *     this.overlay.close();\n *     this.overlay = null;\n *   }\n * }\n * ```\n * In our HTML template, we can then add this behavior to a `<div>` or any other element with the `tooltip` selector,\n * like so:\n *\n *  ```\n * <div tooltip=\"some text here\"></div>\n * ```\n *\n * @publicModule angular2/annotations\n */\nexport class Decorator extends Directive {\n\n  /**\n   * If set to true the compiler does not compile the children of this directive.\n   */\n  //TODO(vsavkin): This would better fall under the Macro directive concept.\n  compileChildren: boolean;\n\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle,\n      compileChildren = true,\n    }:{\n      selector:string,\n      bind:any,\n      events:any,\n      lifecycle:List,\n      compileChildren:boolean\n    }={})\n  {\n    super({\n        selector: selector,\n        bind: bind,\n        events: events,\n        lifecycle: lifecycle\n    });\n    this.compileChildren = compileChildren;\n  }\n}\n\n/**\n * Directive that controls the instantiation, destruction, and positioning of inline template elements.\n *\n * A viewport directive uses a [ViewContainer] to instantiate, insert, move, and destroy views at runtime.\n * The [ViewContainer] is created as a result of `<template>` element, and represents a location in the current view\n * where these actions are performed.\n *\n * Views are always created as children of the current [View], and as siblings of the `<template>` element. Thus a\n * directive in a child view cannot inject the viewport directive that created it.\n *\n * Since viewport directives are common in Angular, and using the full `<template>` element syntax is wordy, Angular\n * also supports a shorthand notation: `<li *foo=\"bar\">` and `<li template=\"foo: bar\">` are equivalent.\n *\n * Thus,\n *\n * ```\n * <ul>\n *   <li *foo=\"bar\" title=\"text\"></li>\n * </ul>\n * ```\n *\n * Expands in use to:\n *\n * ```\n * <ul>\n *   <template [foo]=\"bar\">\n *     <li title=\"text\"></li>\n *   </template>\n * </ul>\n * ```\n *\n * Notice that although the shorthand places `*foo=\"bar\"` within the `<li>` element, the binding for the `Viewport`\n * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.\n *\n *\n * ## Example\n *\n * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.\n *\n * Here is a simple viewport directive that triggers on an `unless` selector:\n *\n * ```\n * @Viewport({\n *   selector: '[unless]',\n *   bind: {\n *     'condition': 'unless'\n *   }\n * })\n * export class Unless {\n *   viewContainer: ViewContainer;\n *   prevCondition: boolean;\n *\n *   constructor(viewContainer: ViewContainer) {\n *     this.viewContainer = viewContainer;\n *     this.prevCondition = null;\n *   }\n *\n *   set condition(newCondition) {\n *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {\n *       this.prevCondition = true;\n *       this.viewContainer.clear();\n *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {\n *       this.prevCondition = false;\n *       this.viewContainer.create();\n *     }\n *   }\n * }\n * ```\n *\n * We can then use this `unless` selector in a template:\n * ```\n * <ul>\n *   <li *unless=\"expr\"></li>\n * </ul>\n * ```\n *\n * Once the viewport instantiates the child view, the shorthand notation for the template expands and the result is:\n *\n * ```\n * <ul>\n *   <template [unless]=\"exp\">\n *     <li></li>\n *   </template>\n *   <li></li>\n * </ul>\n * ```\n *\n * Note also that although the `<li></li>` template still exists inside the `<template></template>`, the instantiated\n * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.\n *\n *\n * @publicModule angular2/annotations\n */\nexport class Viewport extends Directive {\n  @CONST()\n  constructor({\n      selector,\n      bind,\n      events,\n      lifecycle\n    }:{\n      selector:string,\n      bind:any,\n      lifecycle:List\n    }={})\n  {\n    super({\n        selector: selector,\n        bind: bind,\n        events: events,\n        lifecycle: lifecycle\n    });\n  }\n}\n\n//TODO(misko): turn into LifecycleEvent class once we switch to TypeScript;\n\n/**\n * Notify a directive whenever a [View] that contains it is destroyed.\n *\n * ## Example\n *\n * ```\n * @Decorator({\n *   ...,\n *   lifecycle: [onDestroy]\n * })\n * class ClassSet {\n *   onDestroy() {\n *     // invoked to notify directive of the containing view destruction.\n *   }\n * }\n * ```\n * @publicModule angular2/annotations\n */\nexport const onDestroy = \"onDestroy\";\n\n\n/**\n * Notify a directive when any of its bindings have changed.\n *\n * This method is called right after the directive's bindings have been checked,\n * and before any of its children's bindings have been checked.\n *\n * It is invoked only if at least one of the directive's bindings has changed.\n *\n * ## Example:\n *\n * ```\n * @Decorator({\n *   selector: '[class-set]',\n *   bind: {\n *     'propA': 'propA'\n *     'propB': 'propB'\n *   },\n *   lifecycle: [onChange]\n * })\n * class ClassSet {\n *   propA;\n *   propB;\n *   onChange(changes:{[idx: string, PropertyUpdate]}) {\n *     // This will get called after any of the properties have been updated.\n *     if (changes['propA']) {\n *       // if propA was updated\n *     }\n *     if (changes['propA']) {\n *       // if propB was updated\n *     }\n *   }\n * }\n *  ```\n * @publicModule angular2/annotations\n */\nexport const onChange = \"onChange\";\n\n/**\n * Notify a directive when the bindings of all its children have been changed.\n *\n * ## Example:\n *\n * ```\n * @Decorator({\n *   selector: '[class-set]',\n *   lifecycle: [onAllChangesDone]\n * })\n * class ClassSet {\n *\n *   onAllChangesDone() {\n *   }\n *\n * }\n *  ```\n * @publicModule angular2/annotations\n */\nexport const onAllChangesDone = \"onAllChangesDone\";\n"]}